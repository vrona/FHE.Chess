---
id: xf41t
title: FHE.Chess Project Flow
file_version: 1.1.2
app_version: 1.6.1
---

## Project

```markdown
## Overview
Create an application that plays Chess against an AI oponent. The moves should be encrypted with FHE so that the AI doesn't see them but can still run its algorithm on them.

## Description
Create a machine-learning-based version of a Chess player which can be executed in FHE, i.e., where the computer does not see the unencrypted moves.
On the player (client) side, the board would be in clear; then, when she plays her move, she encrypts the new position and sends it to the server, which then runs the machine-learning model inference over encrypted data, to predict a new (encrypted) move to apply. Finally, the player decrypts this move and apply it on the position, and reiterate the process until the game is over.
```

`ðŸ“„ README.md`

While reading you will based faced to SOURCE and TARGET terms. As a chessboard is made of 64 squares (8\*8), source and target are respectively: the selected square of the piece to move from, the selected square of the piece to move to.

## #0 Set up

<br/>


<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ requirements_full.txt
```text
1      brevitas==0.8.0
2      chess==1.9.4
3      concrete-ml>=0.4.0
4      numpy==1.23.5
5      pandas==1.5.2
6      pygame==2.1.2
7      torch==1.13.1
8      tqdm==4.64.1
9      wandb==0.13.10
```

<br/>

<br/>

## #1 Chess App.

The AI needs an environment to take input from and to propose output to.

The development of the app can be done completely from scratch or based on [python-chess](https://python-chess.readthedocs.io/en/latest/) library.

It happens that this project is based on both (to speed up development).

From scratch everything from `ðŸ“„ client/chess_env` except the class `ðŸ“„ client/chess_env/clone_chess.py` which return python-chess methods.

## #2 Data

Data used is downloadable here [https://www.kaggle.com/datasets/arevel/chess-games](https://www.kaggle.com/datasets/arevel/chess-games)

*   Data explanation [Data Explanation](data-explanation.4esp0.sw.md)

*   Data preparation is explained here `ðŸ“„ data/wb_2000.ipynb`

*   Data transformation (to matrix and flat)

    *   for source model `ðŸ“„ code_src/model_src/helper_chess_v7_64source.py`

    *   for target model `ðŸ“„ code_src/model_src/helper_chess_v7_64target.py`

## #3 Models

The chosen philosophy is straightforward: train one model to determine the SOURCE square (no matter the piece and evaluation), train another model to determine the TARGET square.

*   **#3.1 clear source / target**

    *   **Source model**

        *   input source : (12,8,8) board -> output source : selected Square number to move FROM as 1D array of shape (64,)

        *   3 convolution layers (hidden size=128) + fully-connected layer (64)

    *   **Target model**

        *   input target : (12,8,8) board + selected Square number to move from as 1D array of shape (64,) -> output target : selected Square number to move TO as 1D array of shape (64,)

        *   3 convolution layers (hidden size=128) + fully-connected layer (64)

*   **#3.2 quantized source / target**

#4 Train / Validation / Test

#5 Model Quantization

#6 Simulation

#7 Compilation

#8 Deployment (client-server)

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBRkhFLkNoZXNzJTNBJTNBdnJvbmE=/docs/xf41t).
